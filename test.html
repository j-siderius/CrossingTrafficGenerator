<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crossing tester</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            display: flex;
            gap: 20px;
        }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 300px;
        }

        button {
            padding: 10px;
            cursor: pointer;
        }

        #output {
            flex: 1;
            background: #f5f5f5;
            padding: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 600px;
            overflow-y: auto;
            box-sizing: border-box;
            resize: vertical;
        }
    </style>
</head>

<body>
    <div id="controls">
        <button onclick="mode = 'node'">Place node</button>
        <button onclick="mode = 'path'">Make path</button>
        <button onclick="selectNone()">Select none</button>
        <button onclick="editJSON()" id="editBtn">Edit JSON</button>
        <button onclick="navigator.clipboard.writeText(JSON.stringify(data, null, 2))">Copy JSON to clipboard</button>

    </div>
    <div id="canvas"></div>
    <div style="display:flex; height:100vh;">
        <textarea name="output" id="output" cols="100" disabled></textarea>
    </div>

    <script>
        let img = null;
        let mode = 'none';
        let data = { "nodes": [], "paths": [] };

        function preload() {
            img = loadImage('tcross-2.png');

            fetch('./tcross-2_test.json')
                .then((response) => response.json())
                .then((json) => {
                    data = json;
                });
        }

        function setup() {
            let canvas = createCanvas(1000, 1000);
            canvas.parent('canvas');
            angleMode(DEGREES);
        }

        function draw() {
            background(220);
            image(img, 0, 0, width, height);

            let controls = document.getElementById("controls");

            data.paths.forEach((path) => {
                beginShape();
                stroke(0);
                strokeWeight(1);
                if (path.highlight) {
                    stroke(255, 0, 0);
                    strokeWeight(3);
                }
                path.nodes.forEach((node) => {
                    noFill();
                    vertex(data.nodes[node.id].x, data.nodes[node.id].y);
                });
                endShape();

                // Tags for paths
                // noStroke();
                // fill(0);
                // textAlign(CENTER, CENTER);
                // text(`path ${path.id}`,
                //     (data.nodes[path.nodes[0].id].x + data.nodes[path.nodes[path.nodes.length - 1].id].x) / 2,
                //     (data.nodes[path.nodes[0].id].y + data.nodes[path.nodes[path.nodes.length - 1].id].y) / 2);
            });

            noStroke();
            data.nodes.forEach((node) => {
                fill(0, 0, 255);
                circle(node.x, node.y, 10, 10);
                fill(0);
                text(`id ${node.id}`, node.x, node.y - 5);
            });

            document.getElementById('output').value = JSON.stringify(data, null, 2);
        }

        let currentPath = [];

        function mouseClicked() {
            if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
                console.log(`Mouse clicked at (${mouseX}, ${mouseY})`);

                if (mode == 'node') {
                    data.nodes.push({
                        "id": data.nodes.length,
                        "x": mouseX,
                        "y": mouseY,
                    });

                } else if (mode == 'path') {
                    let nearestNode = findNearestNode(mouseX, mouseY, 10);
                    console.log(nearestNode);

                    currentPath.push({
                        "id": nearestNode.id
                    });
                }
            }
        }

        function findNearestNode(x, y, maxDist) {
            let closest = null;
            let minDist = Infinity;

            data.nodes.forEach(node => {
                const d = dist(x, y, node.x, node.y);
                if (d < minDist && d < maxDist) {
                    minDist = d;
                    closest = node;
                }
            });

            return closest;
        }

        function selectNone() {
            mode = 'none';
            data.paths.push({
                "id": data.paths.length,
                "highlight": false,
                "vehicleTypes": [],
                "nodes": currentPath
            });
            currentPath = [];
        }

        let editing = false;

        function editJSON() {
            if (!editing) {
                editing = true;
                document.getElementById('editBtn').innerHTML = "Stop editing";
                document.getElementById('output').disabled = false;
                noLoop();
            } else {
                editing = false;
                document.getElementById('editBtn').innerHTML = "Edit JSON";
                document.getElementById('output').disabled = true;
                data = JSON.parse(document.getElementById('output').value);
                loop();
            }
        }
    </script>
</body>

</html>