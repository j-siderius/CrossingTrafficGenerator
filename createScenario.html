<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crossing Maker</title>
    <link rel="icon" href="assets/images/favicon_highway.png" type="image/png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>

    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #f4f6f7;
            --text-color: #2c3e50;
            --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --input-border-color: #bdc3c7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            gap: 1.5rem;
            padding: 1.5rem;
            height: 100vh;
        }

        #canvas {
            flex: 1;
            background-color: white;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
        }

        #actors {
            width: 50%;
            height: 100%;
            overflow: auto;
        }

        #controls {
            background-color: white;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            height: 100%;
            overflow: auto;
        }

        input,
        select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--input-border-color);
            border-radius: 6px;
            font-size: 1rem;
            appearance: none;
            background-color: white;
            margin-bottom: 0.5rem;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
            margin-bottom: 0.5rem;
        }

        button:hover {
            background-color: var(--secondary-color);
        }

        #interactions-container {
            background-color: #f1f4f8;
            border-radius: 6px;
            padding: 1rem;
            margin-top: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }

        @media (max-width: 1024px) {
            body {
                flex-direction: column;
                height: auto;
            }

            #actors,
            #canvas {
                width: 100%;
                height: auto;
            }
        }

        /* Additional styling for output-like elements */
        #output,
        #interactions-container {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f1f4f8;
            border-radius: 6px;
            padding: 1rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: auto;
            resize: vertical;
        }

        /* Modal styling */
        .modal {
            display: block;
            /* Hidden by default */
            position: fixed;
            /* Stay in place */
            z-index: 1;
            /* Sit on top */
            padding-top: 100px;
            /* Location of the box */
            left: 0;
            top: 0;
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
            overflow: auto;
            /* Enable scroll if needed */
            background-color: rgb(0, 0, 0);
            /* Fallback color */
            background-color: rgba(0, 0, 0, 0.4);
            /* Black w/ opacity */
        }

        /* Modal Content */
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }

        .modal img {
            width: 100%
        }

        .modal p {
            text-align: center;
        }

        .modal button {
            margin-left: auto;
            margin-right: auto;
        }

        .modal td {
            padding: 1em;
        }

        /* The Close Button */
        .close {
            color: #aaaaaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: #000;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <!-- Contains the instruction modal -->
    <div id="myModal" class="modal">

        <!-- Modal content -->
        <div class="modal-content">
            <!-- <p>Some text in the Modal..</p> -->
            <table>
                <tr>
                    <td><img src="assets/images/tutorial_setup.png" alt="" class="modal-image"></td>
                    <td><img src="assets/images/tutorial_actor.png" alt="" class="modal-image"></td>
                    <td><img src="assets/images/tutorial_matrix.png" alt="" class="modal-image"></td>
                </tr>
                <tr>
                    <td>
                        <p>Begin door het scenario een naam te geven (in het tekstveld 'Scenario naam'). Selecteer
                            daarna het type kruispunt waar het scenario zich afspeelt (via de dropdown).</p>
                    </td>
                    <td>
                        <p>Selecteer het type actor en klik op 'Plaats actor'. De actor kan nu met de muis
                            gepositioneerd worden, klik om te plaatsen. Na het vastleggen van de positie kan de rotatie
                            van de actor worden bepaald, klik op vast te leggen. Als laatste wordt het doel van de actor
                            vastgelegd, klik ook om deze vast te leggen. Deze stap herhalen tot alle gewenste actoren
                            geplaatst zijn.</p>
                    </td>
                    <td>
                        <p>Als laatste worden alle interacties tussen de actoren in het scenario bepaald. In de matrix
                            kan de winnaar en de reden van voorrang aangegeven worden (via de dropdowns). Doe dit voor
                            alle interacties. Hierna kan het scenario opgeslagen of gekopieerd worden.</p>
                    </td>
                </tr>
                <tr>
                    <td></td>
                    <td>
                        <button onclick="changeModal()">Sluiten</button>
                    </td>
                    <td></td>
                </tr>
            </table>
        </div>

    </div>

    <!-- Contains the scenario visualiser -->
    <div id="canvas"></div>

    <div style="display:flex;" id="actors">
        <!-- Contains all control elements to build a scenario -->
        <div id="controls">
            <input type="text" id="scenarioName" minlength="4" placeholder="Scenario naam"
                onchange="changeScenarioName()" />

            <select onchange="changeCrossingSource()" id="crossingSource">
                <option value="" disabled selected>Selecteer type kruispunt</option>
                <option value="kruispunt_4weg">Kruispunt 4-weg met zebrapad</option>
                <option value="kruispunt_3weg_uitrit">T-splitsing met uitrit</option>
                <option value="kruispunt_eenrichting_inrit">Kruispunt 4-weg met eenrichting uitrit</option>
                <option value="kruispunt_onverhard">T-splitsing met onverharde weg</option>
                <option value="kruispunt_t">T-splitsing met voorrangsweg</option>
            </select>

            <select onchange="" id="actorType">
                <option value="" disabled selected>Selecteer type actor</option>
                <option value="voetganger">Voetganger</option>
                <option value="fietser">Fietser</option>
                <option value="auto1">Auto</option>
            </select>

            <button onclick="changeActorPlace()" id="actorSet">Plaats actor</button>

            <div class="button-group">
                <button onclick="navigator.clipboard.writeText(JSON.stringify(data, null, 2))">Kopiëer JSON van
                    kruispunt</button>
                <button onclick="downloadJSON()">Download JSON van kruispunt</button>
            </div>

            <!-- Contains the interactions table -->
            <div id="interactions-container" onchange="changedInteractions()"></div>


            <a href="index.html">
                < Terug naar Home</a>
        </div>
    </div>

    <script>
        // Main data object
        let data = {
            "scenario_name": "",
            "background": "",
            "actors": [],
            "interactions": []
        };

        // Builds a JSON file from the scenario data, names it using an MD5 hashing function to generate unique name, then downloads
        function downloadJSON() {
            let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
            let downloadAnchorNode = document.createElement('a');
            let downloadName = String(Math.floor(Math.random() * 999999999999)).padStart(12, '0');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", downloadName + ".json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        // Actor placement variable
        let placeActor = "idle";
        // Enabled the actor placing flow
        function changeActorPlace() {
            if (placeActor == "idle") {
                document.getElementById('actorSet').disabled = true;
                placeActor = "place";
            }
        }

        // Sets up the scenario visualiser
        function setup() {
            let canvas = createCanvas(1000, 1000);
            canvas.parent('canvas');
            angleMode(DEGREES);
        }

        // Object for temporary actor data during placement
        let tempActor = {};
        function mousePressed() {
            // If the mouse is pressed in the visualiser, and the actor placing flow is active
            if (placeActor == "place") {
                // Place the actor and store the x,y values of the actor
                tempActor.type = document.getElementById('actorType').value;
                tempActor.x = mouseX;
                tempActor.y = mouseY;
                placeActor = "rotate";
            } else if (placeActor == "rotate") {
                // Lock the actor rotation and store the angle of the actor
                tempActor.rotation = map(mouseY, 0, height, 0, 360);
                placeActor = "destination";
            } else if (placeActor == "destination") {
                // Store the actor type, location, rotation and destination point
                data.actors.push({
                    "id": data.actors.length,
                    "type": tempActor.type,
                    "x": tempActor.x,
                    "y": tempActor.y,
                    "rotation": tempActor.rotation,
                    "destination": {
                        "x": mouseX,
                        "y": mouseY
                    }
                });

                // Clear the temporary actor data, reload the interactions table, reset the actor placing flow
                tempActor = {};
                loadInteractions(data);
                placeActor = "idle";
                document.getElementById('actorSet').disabled = false;
            }
        }

        // Main visualiser variables
        let crossingImg = null;
        // Main draw loop
        function draw() {
            // Draw the background and current crossing image
            background(220);
            if (crossingImg) image(crossingImg, 0, 0, width, height);

            if (placeActor == "place") {
                let actorType = document.getElementById('actorType').value;
                let tempImg = actorImgs.find((item) => item.type == actorType).img;
                image(tempImg, mouseX - tempImg.width / 2, mouseY - tempImg.height / 2);
            } else if (placeActor == "rotate") {
                let tempImg = actorImgs.find((item) => item.type == tempActor.type).img;
                push();
                translate(tempActor.x, tempActor.y);
                rotate(map(mouseY, 0, height, 0, 360));
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();
            } else if (placeActor == "destination") {
                drawArrow(tempActor.x, tempActor.y, mouseX, mouseY);

                let tempImg = actorImgs.find((item) => item.type == tempActor.type).img;
                push();
                translate(tempActor.x, tempActor.y);
                rotate(tempActor.rotation);
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();
            }

            // Draw all the actors in the data object
            data.actors.forEach(actor => {
                // Draw the destination arrow for the actor
                if (actor.destination) drawArrow(actor.x, actor.y, actor.destination.x, actor.destination.y);

                // Find the corresponding actor image, then place it according the the position and rotation
                let tempImg = actorImgs.find((item) => item.type == actor.type).img;
                push();
                translate(actor.x, actor.y);
                rotate(actor.rotation);
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();

                // Draw the actor ID for identification
                fill(255);
                stroke(0);
                strokeWeight(2);
                textSize(25);
                text(`${actor.id}`, actor.x - 7, actor.y + 5);
                noStroke();
            });

        }

        // -------------HELPERS-----------------------------------------------------------------

        // Disable the modal with instructions
        function changeModal() {
            let modalDOM = document.getElementById('myModal');
            let visibility = modalDOM.style.display;
            if (visibility != "none") modalDOM.style.display = "none";
            else modalDOM.style.display = "block";
        }

        // Draw the destination arrow to indicate where actors want to travel to
        function drawArrow(startX, startY, endX, endY) {
            // Calculate the angle and length of the arrow
            let angle = atan2(endY - startY, endX - startX);
            let distance = dist(startX, startY, endX, endY);

            // Draw the angle at the start coordinates
            push();
            translate(startX, startY);
            rotate(angle);

            stroke(0);
            strokeWeight(2);
            line(0, 0, distance, 0);

            // Draw the arrow head at the destination coordinates using the calculated vector
            fill(0);
            noStroke();
            beginShape();
            vertex(distance, 0);
            vertex(distance - 10, -5);
            vertex(distance - 10, 5);
            endShape(CLOSE);
            pop();
        }

        // Change the scenario name in the data object
        function changeScenarioName() {
            let scenarioName = document.getElementById('scenarioName').value;
            data.scenario_name = scenarioName;
        }

        // Change the crossing image in the data object and for drawing in the visualiser
        function changeCrossingSource() {
            let crossingSource = document.getElementById('crossingSource').value;
            crossingImg = loadImage('./assets/images/' + crossingSource + ".png");
            data.background = "./assets/images/" + crossingSource + ".png";
        }

        // Define actor image variable to house all actor image objects
        let actorImgs = [];
        let config = null;
        // Load data before the visualiser is started
        function preload() {

            fetch('./config.json')
                .then((response) => response.json())
                .then((json) => {
                    config = json;

                    config.actors.forEach((actor) => {
                        actorImgs.push({
                            "type": actor.identifier,
                            "img": loadImage(actor.file)
                        });
                    });
                });
        }

        // ------------INTERACTIONS--------------------------------------------

        // Store interaction elements for extraction
        const interactionElements = [];
        // Store all possible reasons for an actor winner
        let reasons = [
            "RVV1: voetganger geen bestuurder",
            "RVV 15.1: rechts voorrang",
            "RVV 15.2A: onverharde weg",
            "RVV 15.2B: trams voorrang",
            "RVV 18.1: rechtd zelfde weg",
            "RVV 18.2: korte vóór lange bocht",
            "RVV 18.3: afslaande tram voorrang",
            "RVV50: voorrangsvoertuig",
            "RVV54: inenuitrit of erf mano",
            "RVV80: haaientanden",
            "RVV80: stopstreep",
            "RVV62: tekens opvolgen",
            "RVV16: colonnes/stoeten",
            "RVV49.1: Overstek blinden/gehand",
            "RVV49.2: VOP",
            "RVV49.3: Kolonnes gaan voor",
            "RVV49.4: VOP rood/glkn voetglicht",
            "RVV74.2: Geel knip voetglicht",
            "Bord B1: voorrangsweg",
            "Bord B2: Einde voorrangsweg",
            "Bord B3: Voorrangskruispunt",
            "Bord B4: Voorrangskruispunt zijweg links",
            "Bord B5: Voorrangskruispunt zijweg rechts",
            "Bord B6: voorrang kruisende weg",
            "Bord B7: stop-verleen kr weg voorrang",
            "RVV68.1a; Rond - groen",
            "RVV68.1b; Rond - geel",
            "RVV68.1c; Rond - rood",
            "RVV68.2; Pijl - groen",
            "RVV68.2; Pijl - geel",
            "RVV68.2; Pijl - rood",
            "RVV68.3; Rood",
            "RVV68.3; Geel",
            "RVV68.3; Groen",
            "RVV68.5; Rood en rechtsaf vrij",
            "RVV 70.1, BT wit",
            "RVV 70.1b, BT geel",
            "RVV 70.1b, BT rood",
            "RVV74.1;VT Groen",
            "RVV74.2; VT Groen knipperend",
            "RVV74.1; VT Rood",
            "RVV74.2; Vt Geel knipperend"
        ]
        // Load all interactions from the data object
        function loadInteractions(data) {
            const actors = data.actors;
            const existingInteractions = data.interactions;

            // Create a set to track unique interactions
            const interactionSet = new Set();

            // Generate interaction matrix
            const container = document.getElementById('interactions-container');
            if (container.firstElementChild) container.removeChild(container.firstElementChild);
            const table = document.createElement('table');

            // Create header row
            const headerRow = document.createElement('tr');
            const emptyCell = document.createElement('th');
            headerRow.appendChild(emptyCell);

            actors.forEach(actor => {
                const headerCell = document.createElement('th');
                headerCell.textContent = `Actor ${actor.id} (${actor.type})`;
                headerRow.appendChild(headerCell);
            });
            table.appendChild(headerRow);

            // Create interaction rows
            actors.forEach((rowActor, rowIndex) => {
                const row = document.createElement('tr');

                // Row header with actor info
                const rowHeader = document.createElement('th');
                rowHeader.textContent = `Actor ${rowActor.id} (${rowActor.type})`;
                row.appendChild(rowHeader);

                actors.forEach((colActor, colIndex) => {
                    const cell = document.createElement('td');

                    // Skip diagonal interactions
                    if (rowIndex === colIndex) {
                        cell.textContent = '-';
                    } else {
                        // Ensure unique interaction order
                        const interactionKey = rowActor.id < colActor.id
                            ? `${rowActor.id}-${colActor.id}`
                            : `${colActor.id}-${rowActor.id}`;

                        if (interactionSet.has(interactionKey)) {
                            cell.textContent = '-';
                        } else {
                            interactionSet.add(interactionKey);

                            // Create winner dropdown
                            const winnerSelect = document.createElement('select');
                            winnerSelect.innerHTML = `
                                <option value="" disabled selected>Select Winner</option>
                                <option value="${rowActor.id}">Actor ${rowActor.id} (${rowActor.type})</option>
                                <option value="${colActor.id}">Actor ${colActor.id} (${colActor.type})</option>
                            `;

                            // Fill the winner reasons according to the reason object
                            const reasonSelect = document.createElement('select');
                            reasonSelect.innerHTML = `<option value="" disabled selected>Select Reason</option>`;
                            reasons.forEach(reason => {
                                reasonSelect.innerHTML += `<option value="${reason}">${reason}</option>`;
                            });

                            // Find existing interaction
                            const existingInteraction = existingInteractions.find(
                                interaction => (
                                    (interaction.actor_pair[0] === rowActor.id &&
                                        interaction.actor_pair[1] === colActor.id) ||
                                    (interaction.actor_pair[0] === colActor.id &&
                                        interaction.actor_pair[1] === rowActor.id)
                                )
                            );

                            // Populate with existing interaction if available
                            if (existingInteraction) {
                                winnerSelect.value = existingInteraction.winner;
                                reasonSelect.value = existingInteraction.reason;
                            }

                            // Store interaction details for later extraction
                            interactionElements.push({
                                actorPair: [rowActor.id, colActor.id],
                                winnerSelect,
                                reasonSelect
                            });

                            // Append dropdowns to cell
                            cell.appendChild(winnerSelect);
                            cell.appendChild(reasonSelect);
                        }
                    }

                    row.appendChild(cell);
                });

                table.appendChild(row);
            });
            // Finally, add all the elements to the table
            container.appendChild(table);
        }

        // If the interactions get changed, save it to the data object
        function changedInteractions() {
            let interactions = [];

            // Run through all interactions and find the relevant values
            interactionElements.forEach((interaction, index) => {
                const winner = interaction.winnerSelect.value;
                const reason = interaction.reasonSelect.value;

                // Only add interactions with both winner and reason selected
                if (winner && reason) {
                    interactions.push({
                        id: interactions.length,
                        actor_pair: interaction.actorPair,
                        winner: parseInt(winner),
                        reason: reason
                    });
                }
            });

            // Add all interactions to the interactions variable in the data object
            data.interactions = interactions;
        }

    </script>

</body>

</html>