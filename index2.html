<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crossing maker</title>
    <link rel="icon" href="assets/images/favicon_highway.png" type="image/png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            display: flex;
            gap: 20px;
        }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 300px;
        }

        button {
            padding: 10px;
            cursor: pointer;
        }

        #output {
            flex: 1;
            background: #f5f5f5;
            padding: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 600px;
            overflow-y: auto;
            box-sizing: border-box;
            resize: vertical;
        }
    </style>
</head>

<body>
    <div id="canvas"></div>
    <div style="display:flex; height:100vh;" id="actors">

        <div id="controls">
            <input type="text" id="scenarioName" minlength="4" placeholder="Scenario naam"
                onchange="changeScenarioName()" />
            <select onchange="changeCrossingSource()" id="crossingSource">
                <option value="" disabled selected>Selecteer type kruispunt</option>
                <option value="kruispunt_4weg">Kruispunt 4-weg met zebrapad</option>
                <option value="kruispunt_3weg_uitrit">T-splitsing met uitrit</option>
                <option value="kruispunt_eenrichting_inrit">Kruispunt 4-weg met eenrichting uitrit</option>
                <option value="kruispunt_onverhard">T-splitsing met onverharde weg</option>
                <option value="kruispunt_t">T-splitsing met voorrangsweg</option>
            </select>
            <br>
            <select onchange="" id="actorType">
                <!-- <option value="" disabled selected>Selecteer type actor</option> -->
                <option value="voetganger" selected>Voetganger</option>
                <option value="fietser">Fietser</option>
                <option value="auto1">Auto</option>
            </select>
            <button onclick="changeActorPlace()" id="actorSet">Plaats actor</button>
            <br>

            <!-- <button onclick=""></button>
        <button onclick=""></button> -->
            <button onclick="navigator.clipboard.writeText(JSON.stringify(data, null, 2))">KopiÃ«er JSON van
                kruispunt</button>

            <br><br>

            <!-- <div id="table-container" onchange="changeInteractionTable()"></div> -->
            <div id="interactions-container" onchange="changedInteractions()"></div>
        </div>
    </div>

    <script>
        let crossingImg = null;

        let actorImgs = [];
        let placeActor = "idle";
        let tempActor = {};

        let data = {
            "scenario_name": "",
            "background": "",
            "actors": [],
            "interactions": []
        };

        function changeInteractionTable() {
            extractActorPairingData();
        }

        function changeActorPlace() {
            if (placeActor == "idle") {
                document.getElementById('actorSet').disabled = true;
                placeActor = "place";
            }
        }

        function setup() {
            let canvas = createCanvas(1000, 1000);
            canvas.parent('canvas');
            angleMode(DEGREES);
        }

        function mousePressed() {
            // >> placeActor > rotateActor > destinationActor > idle >>
            if (placeActor == "place") {
                tempActor.type = document.getElementById('actorType').value;
                tempActor.x = mouseX;
                tempActor.y = mouseY;
                placeActor = "rotate";
            } else if (placeActor == "rotate") {
                tempActor.rotation = map(mouseY, 0, height, 0, 360);
                placeActor = "destination";
            } else if (placeActor == "destination") {
                data.actors.push({
                    "id": data.actors.length,
                    "type": tempActor.type,
                    "x": tempActor.x,
                    "y": tempActor.y,
                    "rotation": tempActor.rotation,
                    "destination": {
                        "x": mouseX,
                        "y": mouseY
                    }
                });
                tempActor = {};
                // createActorPairingTable(data.actors);
                loadInteractions(data);
                placeActor = "idle";
                document.getElementById('actorSet').disabled = false;
            }
        }

        function draw() {
            background(220);
            image(crossingImg, 0, 0, width, height);

            if (placeActor == "place") {
                let actorType = document.getElementById('actorType').value;
                let tempImg = actorImgs.find((item) => item.type == actorType).img;
                image(tempImg, mouseX - tempImg.width / 2, mouseY - tempImg.height / 2);
            } else if (placeActor == "rotate") {
                let tempImg = actorImgs.find((item) => item.type == tempActor.type).img;
                push();
                translate(tempActor.x, tempActor.y);
                rotate(map(mouseY, 0, height, 0, 360));
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();
            } else if (placeActor == "destination") {
                let tempImg = actorImgs.find((item) => item.type == tempActor.type).img;
                push();
                translate(tempActor.x, tempActor.y);
                rotate(tempActor.rotation);
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();

                drawArrow(tempActor.x, tempActor.y, mouseX, mouseY);
            }

            data.actors.forEach(actor => {
                let tempImg = actorImgs.find((item) => item.type == actor.type).img;
                push();
                translate(actor.x, actor.y);
                rotate(actor.rotation);
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();

                fill(255);
                stroke(0);
                strokeWeight(2);
                textSize(25);
                text(`id ${actor.id}`, actor.x, actor.y);
                noStroke();

                if (actor.destination) drawArrow(actor.x, actor.y, actor.destination.x, actor.destination.y);
            });

        }

        // -------------HELPERS-----------------------------------------------------------------

        function drawArrow(startX, startY, endX, endY) {
            // Calculate the angle and length of the arrow
            let angle = atan2(endY - startY, endX - startX);
            let distance = dist(startX, startY, endX, endY);

            // Save the current drawing state
            push();

            // Move to the start point
            translate(startX, startY);

            // Rotate to align with the arrow direction
            rotate(angle);

            // Draw the arrow shaft
            stroke(0);
            strokeWeight(2);
            line(0, 0, distance, 0);

            // Draw the arrowhead
            fill(0);
            noStroke();

            // Arrowhead triangle
            beginShape();
            vertex(distance, 0);
            vertex(distance - 10, -5);
            vertex(distance - 10, 5);
            endShape(CLOSE);

            // Restore the drawing state
            pop();
        }

        function changeScenarioName() {
            let scenarioName = document.getElementById('scenarioName').value;
            data.scenario_name = scenarioName;
        }

        function changeCrossingSource() {
            let crossingSource = document.getElementById('crossingSource').value;
            crossingImg = loadImage('./assets/images/' + crossingSource + ".png");
            data.background = "./assets/images/" + crossingSource + ".png";
        }

        function preload() {
            // TODO: default image, remove if final
            crossingImg = loadImage('./assets/images/kruispunt_4weg.png');

            // add all actors
            actorImgs.push({
                "type": "voetganger",
                "img": loadImage('./assets/images/voetganger.png')
            });
            actorImgs.push({
                "type": "fietser",
                "img": loadImage('./assets/images/fietser.png')
            });
            actorImgs.push({
                "type": "auto1",
                "img": loadImage('./assets/images/auto1.png')
            });

            fetch('./assets/scenarios/0001.json')
                .then((response) => response.json())
                .then((json) => {
                    data = json;
                    loadInteractions(data);
                    // createActorPairingTable(data.actors);
                    // createTable();
                });


        }

        // ------------INTERACTIONS--------------------------------------------

        // Store interaction elements for extraction
        const interactionElements = [];

        function loadInteractions(data) {
            const actors = data.actors;
            const existingInteractions = data.interactions;

            // Create a set to track unique interactions
            const interactionSet = new Set();

            // Generate interaction matrix
            const container = document.getElementById('interactions-container');
            if (container.firstElementChild) container.removeChild(container.firstElementChild);
            const table = document.createElement('table');

            // Create header row
            const headerRow = document.createElement('tr');
            const emptyCell = document.createElement('th');
            headerRow.appendChild(emptyCell);

            actors.forEach(actor => {
                const headerCell = document.createElement('th');
                headerCell.textContent = `Actor ${actor.id} (${actor.type})`;
                headerRow.appendChild(headerCell);
            });
            table.appendChild(headerRow);

            // Create interaction rows
            actors.forEach((rowActor, rowIndex) => {
                const row = document.createElement('tr');

                // Row header with actor info
                const rowHeader = document.createElement('th');
                rowHeader.textContent = `Actor ${rowActor.id} (${rowActor.type})`;
                row.appendChild(rowHeader);

                actors.forEach((colActor, colIndex) => {
                    const cell = document.createElement('td');

                    // Skip diagonal interactions
                    if (rowIndex === colIndex) {
                        cell.textContent = '-';
                    } else {
                        // Ensure unique interaction order
                        const interactionKey = rowActor.id < colActor.id
                            ? `${rowActor.id}-${colActor.id}`
                            : `${colActor.id}-${rowActor.id}`;

                        if (interactionSet.has(interactionKey)) {
                            cell.textContent = '-';
                        } else {
                            interactionSet.add(interactionKey);

                            // Create winner dropdown
                            const winnerSelect = document.createElement('select');
                            winnerSelect.innerHTML = `
                                <option value="" disabled selected>Select Winner</option>
                                <option value="${rowActor.id}">Actor ${rowActor.id} (${rowActor.type})</option>
                                <option value="${colActor.id}">Actor ${colActor.id} (${colActor.type})</option>
                            `;

                            // Create reason dropdown
                            let reasons = [
                                "Rechtdoor op zelfde weg",
                                "Voetgangersoversteekplaats (VOP)",
                                "Voorrangsweg"
                            ]

                            const reasonSelect = document.createElement('select');
                            reasonSelect.innerHTML = `<option value="" disabled selected>Select Reason</option>`;
                            reasons.forEach(reason => {
                                reasonSelect.innerHTML += `<option value="${reason}">${reason}</option>`;
                            });

                            // Find existing interaction
                            const existingInteraction = existingInteractions.find(
                                interaction => (
                                    (interaction.actor_pair[0] === rowActor.id &&
                                        interaction.actor_pair[1] === colActor.id) ||
                                    (interaction.actor_pair[0] === colActor.id &&
                                        interaction.actor_pair[1] === rowActor.id)
                                )
                            );

                            // Populate with existing interaction if available
                            if (existingInteraction) {
                                winnerSelect.value = existingInteraction.winner;
                                reasonSelect.value = existingInteraction.reason;
                            }

                            // Store interaction details for later extraction
                            interactionElements.push({
                                actorPair: [rowActor.id, colActor.id],
                                winnerSelect,
                                reasonSelect
                            });

                            // Append dropdowns to cell
                            cell.appendChild(winnerSelect);
                            cell.appendChild(reasonSelect);
                        }
                    }

                    row.appendChild(cell);
                });

                table.appendChild(row);
            });

            container.appendChild(table);
        }

        function changedInteractions() {
            let interactions = [];

            interactionElements.forEach((interaction, index) => {
                const winner = interaction.winnerSelect.value;
                const reason = interaction.reasonSelect.value;

                // Only add interactions with both winner and reason selected
                if (winner && reason) {
                    interactions.push({
                        id: interactions.length,
                        actor_pair: interaction.actorPair,
                        winner: parseInt(winner),
                        reason: reason
                    });
                }
            });

            data.interactions = interactions;
        }

    </script>

</body>

</html>