<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crossing maker</title>
    <link rel="icon" href="assets/images/favicon_highway.png" type="image/png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            display: flex;
            gap: 20px;
        }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 300px;
        }

        button {
            padding: 10px;
            cursor: pointer;
        }

        #output {
            flex: 1;
            background: #f5f5f5;
            padding: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 600px;
            overflow-y: auto;
            box-sizing: border-box;
            resize: vertical;
        }
    </style>
</head>

<body>
    <!-- Contains the scenario visualiser -->
    <div id="canvas"></div>

    <div style="display:flex; height:100vh;" id="actors">
        <!-- Contains all control elements to build a scenario -->
        <div id="controls">
            <input type="text" id="scenarioName" minlength="4" placeholder="Scenario naam"
                onchange="changeScenarioName()" />
            <select onchange="changeCrossingSource()" id="crossingSource">
                <option value="" disabled selected>Selecteer type kruispunt</option>
                <option value="kruispunt_4weg">Kruispunt 4-weg met zebrapad</option>
                <option value="kruispunt_3weg_uitrit">T-splitsing met uitrit</option>
                <option value="kruispunt_eenrichting_inrit">Kruispunt 4-weg met eenrichting uitrit</option>
                <option value="kruispunt_onverhard">T-splitsing met onverharde weg</option>
                <option value="kruispunt_t">T-splitsing met voorrangsweg</option>
            </select>

            <select onchange="" id="actorType">
                <option value="" disabled selected>Selecteer type actor</option>
                <option value="voetganger">Voetganger</option>
                <option value="fietser">Fietser</option>
                <option value="auto1">Auto</option>
            </select>
            <button onclick="changeActorPlace()" id="actorSet">Plaats actor</button>

            <button onclick="navigator.clipboard.writeText(JSON.stringify(data, null, 2))">KopiÃ«er JSON van
                kruispunt</button>
            <button onclick="downloadJSON()">Download JSON van kruispunt</button>

            <br><br>

            <!-- Contains the interactions table -->
            <div id="interactions-container" onchange="changedInteractions()"></div>
        </div>
    </div>

    <script>
        // Main data object
        let data = {
            "scenario_name": "",
            "background": "",
            "actors": [],
            "interactions": []
        };

        // Builds a JSON file from the scenario data, names it using an MD5 hashing function to generate unique name, then downloads
        function downloadJSON() {
            let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
            let downloadAnchorNode = document.createElement('a');
            let downloadName = md5(data);
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", downloadName + ".json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        // Actor placement variable
        let placeActor = "idle";
        // Enabled the actor placing flow
        function changeActorPlace() {
            if (placeActor == "idle") {
                document.getElementById('actorSet').disabled = true;
                placeActor = "place";
            }
        }

        // Sets up the scenario visualiser
        function setup() {
            let canvas = createCanvas(1000, 1000);
            canvas.parent('canvas');
            angleMode(DEGREES);
        }

        // Object for temporary actor data during placement
        let tempActor = {};
        function mousePressed() {
            // If the mouse is pressed in the visualiser, and the actor placing flow is active
            if (placeActor == "place") {
                // Place the actor and store the x,y values of the actor
                tempActor.type = document.getElementById('actorType').value;
                tempActor.x = mouseX;
                tempActor.y = mouseY;
                placeActor = "rotate";
            } else if (placeActor == "rotate") {
                // Lock the actor rotation and store the angle of the actor
                tempActor.rotation = map(mouseY, 0, height, 0, 360);
                placeActor = "destination";
            } else if (placeActor == "destination") {
                // Store the actor type, location, rotation and destination point
                data.actors.push({
                    "id": data.actors.length,
                    "type": tempActor.type,
                    "x": tempActor.x,
                    "y": tempActor.y,
                    "rotation": tempActor.rotation,
                    "destination": {
                        "x": mouseX,
                        "y": mouseY
                    }
                });

                // Clear the temporary actor data, reload the interactions table, reset the actor placing flow
                tempActor = {};
                loadInteractions(data);
                placeActor = "idle";
                document.getElementById('actorSet').disabled = false;
            }
        }

        // Main visualiser variables
        let crossingImg = null;
        // Main draw loop
        function draw() {
            // Draw the background and current crossing image
            background(220);
            image(crossingImg, 0, 0, width, height);

            if (placeActor == "place") {
                let actorType = document.getElementById('actorType').value;
                let tempImg = actorImgs.find((item) => item.type == actorType).img;
                image(tempImg, mouseX - tempImg.width / 2, mouseY - tempImg.height / 2);
            } else if (placeActor == "rotate") {
                let tempImg = actorImgs.find((item) => item.type == tempActor.type).img;
                push();
                translate(tempActor.x, tempActor.y);
                rotate(map(mouseY, 0, height, 0, 360));
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();
            } else if (placeActor == "destination") {
                let tempImg = actorImgs.find((item) => item.type == tempActor.type).img;
                push();
                translate(tempActor.x, tempActor.y);
                rotate(tempActor.rotation);
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();

                drawArrow(tempActor.x, tempActor.y, mouseX, mouseY);
            }

            // Draw all the actors in the data object
            data.actors.forEach(actor => {
                // Find the corresponding actor image, then place it according the the position and rotation
                let tempImg = actorImgs.find((item) => item.type == actor.type).img;
                push();
                translate(actor.x, actor.y);
                rotate(actor.rotation);
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();

                // Draw the actor ID for identification
                fill(255);
                stroke(0);
                strokeWeight(2);
                textSize(25);
                text(`${actor.id}`, actor.x, actor.y);
                noStroke();

                // Draw the destination arrow for the actor
                if (actor.destination) drawArrow(actor.x, actor.y, actor.destination.x, actor.destination.y);
            });

        }

        // -------------HELPERS-----------------------------------------------------------------

        // Draw the destination arrow to indicate where actors want to travel to
        function drawArrow(startX, startY, endX, endY) {
            // Calculate the angle and length of the arrow
            let angle = atan2(endY - startY, endX - startX);
            let distance = dist(startX, startY, endX, endY);

            // Draw the angle at the start coordinates
            push();
            translate(startX, startY);
            rotate(angle);

            stroke(0);
            strokeWeight(2);
            line(0, 0, distance, 0);

            // Draw the arrow head at the destination coordinates using the calculated vector
            fill(0);
            noStroke();
            beginShape();
            vertex(distance, 0);
            vertex(distance - 10, -5);
            vertex(distance - 10, 5);
            endShape(CLOSE);
            pop();
        }

        // Change the scenario name in the data object
        function changeScenarioName() {
            let scenarioName = document.getElementById('scenarioName').value;
            data.scenario_name = scenarioName;
        }

        // Change the crossing image in the data object and for drawing in the visualiser
        function changeCrossingSource() {
            let crossingSource = document.getElementById('crossingSource').value;
            crossingImg = loadImage('./assets/images/' + crossingSource + ".png");
            data.background = "./assets/images/" + crossingSource + ".png";
        }

        // Define actor image variable to house all actor image objects
        let actorImgs = [];
        // Load data before the visualiser is started
        function preload() {
            // TODO: default image, remove if final
            crossingImg = loadImage('./assets/images/kruispunt_4weg.png');

            // Load all actor images and put the in an image array for easy access
            actorImgs.push({
                "type": "voetganger",
                "img": loadImage('./assets/images/voetganger.png')
            });
            actorImgs.push({
                "type": "fietser",
                "img": loadImage('./assets/images/fietser.png')
            });
            actorImgs.push({
                "type": "auto1",
                "img": loadImage('./assets/images/auto1.png')
            });

            // TODO: default scenario, remove if final
            fetch('./assets/scenarios/0001.json')
                .then((response) => response.json())
                .then((json) => {
                    data = json;
                    loadInteractions(data);
                });
        }

        // ------------INTERACTIONS--------------------------------------------

        // Store interaction elements for extraction
        const interactionElements = [];
        // Store all possible reasons for an actor winner
        let reasons = [
            "Rechtdoor op zelfde weg",
            "Voetgangersoversteekplaats (VOP)",
            "Voorrangsweg"
        ]
        // Load all interactions from the data object
        function loadInteractions(data) {
            const actors = data.actors;
            const existingInteractions = data.interactions;

            // Create a set to track unique interactions
            const interactionSet = new Set();

            // Generate interaction matrix
            const container = document.getElementById('interactions-container');
            if (container.firstElementChild) container.removeChild(container.firstElementChild);
            const table = document.createElement('table');

            // Create header row
            const headerRow = document.createElement('tr');
            const emptyCell = document.createElement('th');
            headerRow.appendChild(emptyCell);

            actors.forEach(actor => {
                const headerCell = document.createElement('th');
                headerCell.textContent = `Actor ${actor.id} (${actor.type})`;
                headerRow.appendChild(headerCell);
            });
            table.appendChild(headerRow);

            // Create interaction rows
            actors.forEach((rowActor, rowIndex) => {
                const row = document.createElement('tr');

                // Row header with actor info
                const rowHeader = document.createElement('th');
                rowHeader.textContent = `Actor ${rowActor.id} (${rowActor.type})`;
                row.appendChild(rowHeader);

                actors.forEach((colActor, colIndex) => {
                    const cell = document.createElement('td');

                    // Skip diagonal interactions
                    if (rowIndex === colIndex) {
                        cell.textContent = '-';
                    } else {
                        // Ensure unique interaction order
                        const interactionKey = rowActor.id < colActor.id
                            ? `${rowActor.id}-${colActor.id}`
                            : `${colActor.id}-${rowActor.id}`;

                        if (interactionSet.has(interactionKey)) {
                            cell.textContent = '-';
                        } else {
                            interactionSet.add(interactionKey);

                            // Create winner dropdown
                            const winnerSelect = document.createElement('select');
                            winnerSelect.innerHTML = `
                                <option value="" disabled selected>Select Winner</option>
                                <option value="${rowActor.id}">Actor ${rowActor.id} (${rowActor.type})</option>
                                <option value="${colActor.id}">Actor ${colActor.id} (${colActor.type})</option>
                            `;

                            // Fill the winner reasons according to the reason object
                            const reasonSelect = document.createElement('select');
                            reasonSelect.innerHTML = `<option value="" disabled selected>Select Reason</option>`;
                            reasons.forEach(reason => {
                                reasonSelect.innerHTML += `<option value="${reason}">${reason}</option>`;
                            });

                            // Find existing interaction
                            const existingInteraction = existingInteractions.find(
                                interaction => (
                                    (interaction.actor_pair[0] === rowActor.id &&
                                        interaction.actor_pair[1] === colActor.id) ||
                                    (interaction.actor_pair[0] === colActor.id &&
                                        interaction.actor_pair[1] === rowActor.id)
                                )
                            );

                            // Populate with existing interaction if available
                            if (existingInteraction) {
                                winnerSelect.value = existingInteraction.winner;
                                reasonSelect.value = existingInteraction.reason;
                            }

                            // Store interaction details for later extraction
                            interactionElements.push({
                                actorPair: [rowActor.id, colActor.id],
                                winnerSelect,
                                reasonSelect
                            });

                            // Append dropdowns to cell
                            cell.appendChild(winnerSelect);
                            cell.appendChild(reasonSelect);
                        }
                    }

                    row.appendChild(cell);
                });

                table.appendChild(row);
            });
            // Finally, add all the elements to the table
            container.appendChild(table);
        }

        // If the interactions get changed, save it to the data object
        function changedInteractions() {
            let interactions = [];

            // Run through all interactions and find the relevant values
            interactionElements.forEach((interaction, index) => {
                const winner = interaction.winnerSelect.value;
                const reason = interaction.reasonSelect.value;

                // Only add interactions with both winner and reason selected
                if (winner && reason) {
                    interactions.push({
                        id: interactions.length,
                        actor_pair: interaction.actorPair,
                        winner: parseInt(winner),
                        reason: reason
                    });
                }
            });

            // Add all interactions to the interactions variable in the data object
            data.interactions = interactions;
        }

    </script>

</body>

</html>