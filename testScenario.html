<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kruispunt tester</title>
    <link rel="icon" href="assets/images/favicon_highway.png" type="image/png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>

    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #f4f6f7;
            --text-color: #2c3e50;
            --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --input-border-color: #bdc3c7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            gap: 1.5rem;
            padding: 1.5rem;
        }

        #canvas {
            flex: 1;
            background-color: white;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
        }

        #actors {
            width: 50%;
            height: 100%;
            overflow: auto;
        }

        #controls {
            background-color: white;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        #crossingSource {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--input-border-color);
            border-radius: 6px;
            font-size: 1rem;
            appearance: none;
            background-color: white;
        }

        fieldset {
            border: 1px solid var(--input-border-color);
            border-radius: 6px;
            padding: 1rem;
        }

        legend {
            padding: 0 0.5rem;
            color: var(--primary-color);
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: var(--secondary-color);
        }

        #resolutionContainer {
            background-color: #f1f4f8;
            border-radius: 6px;
            padding: 1rem;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        @media (max-width: 1024px) {
            body {
                flex-direction: column;
            }

            #actors,
            #canvas {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <!-- Contains the scenario visualiser -->
    <div id="canvas"></div>

    <div style="display:flex; height:100vh;" id="actors">
        <!-- Contains all control elements to build a scenario -->
        <div id="controls">

            <select onchange="changeScenario()" id="crossingSource">
                <option value="initialValue" disabled selected>Selecteer een scenario</option>
            </select>

            <form onsubmit="checkAnswer(event)">
                <fieldset id="test" disabled>
                    <legend id="question"></legend>
                    <div id="answers">
                    </div>
                    <div>
                        <br>
                        <button type="submit">Controleer antwoord</button>
                    </div>
                </fieldset>
            </form>
            <div id="resolutionContainer">
                <div id="correctness"></div>
                <div id="explanation" style="display:none;"></div>
            </div>
            <a href="index.html">
                < Terug naar Home</a>
        </div>

    </div>

    <script>
        // Main data object
        let data = {
            "scenario_name": "",
            "background": "",
            "actors": [],
            "interactions": []
        };

        // Sets up the scenario visualiser
        function setup() {
            let canvas = createCanvas(1000, 1000);
            canvas.parent('canvas');
            angleMode(DEGREES);
        }

        // Main visualiser variables
        let crossingImg = null;
        // Main draw loop
        function draw() {
            // Draw the background and current crossing image
            background(220);
            if (crossingImg) image(crossingImg, 0, 0, width, height);

            // Draw all the actors in the data object
            data.actors.forEach(actor => {
                // Draw the destination arrow for the actor
                if (actor.destination) drawArrow(actor.x, actor.y, actor.destination.x, actor.destination.y);

                // Find the corresponding actor image, then place it according the the position and rotation
                let tempImg = actorImgs.find((item) => item.type == actor.type).img;
                push();
                translate(actor.x, actor.y);
                rotate(actor.rotation);
                image(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                pop();

                // Draw the actor ID for identification
                fill(255);
                stroke(0);
                strokeWeight(2);
                textSize(25);
                text(`${actor.id}`, actor.x - 7, actor.y + 5);
                noStroke();
            });

        }

        // -------------HELPERS-----------------------------------------------------------------

        let answer = null;
        let possibilities = null;
        function questionGenerator() {
            const questionTypes = ["whogoesfirst", "whichrule"];
            let questionType = questionTypes[Math.floor(Math.random() * questionTypes.length)]

            // console.log(`questionType=${questionType}`);

            let questionDOM = document.getElementById('question');
            let answersDOM = document.getElementById('answers');
            let explanationDOM = document.getElementById('explanation');

            questionDOM.innerHTML = "";
            answersDOM.innerHTML = "";
            explanationDOM.innerHTML = "";

            switch (questionType) {
                case "whogoesfirst":
                    if (data.actors.length > 2) {
                        // What is the correct order of going
                        answer = determineWinnerOrder(data.interactions);
                        possibilities = generatePermutations(data.actors.length);
                        // console.log(`Who goes first in order? Answer possibilities: ${possibilities}, correct answer ${answer}`);

                        questionDOM.innerHTML = "Wat is de correcte volgorde?";
                        explanationDOM.innerHTML = `<p><b>De correcte volgorde is ${answer}.</b><br></p>`;

                    } else {
                        // Who goes first
                        answer = data.interactions[0].winner;
                        possibilities = data.interactions[0].actor_pair;
                        // console.log(`Who goes first? Answer possiblities: ${possibilities}, correct answer: ${answer}`);

                        questionDOM.innerHTML = "Wie gaat er voor?";
                        explanationDOM.innerHTML = `<p><b>Weggebruiker ${answer} gaat voor.</b><br> Dit komt door de volgende regel: ${data.interactions[0].reason}</p>`;
                    }

                    possibilities.forEach((possibility) => {
                        let tempRadio = document.createElement('input');
                        tempRadio.type = "radio";
                        tempRadio.id = possibility;
                        tempRadio.name = "actors";
                        tempRadio.value = possibility;
                        answersDOM.append(tempRadio);
                        let tempLabel = document.createElement('label');
                        tempLabel.for = possibility;
                        tempLabel.innerHTML = `Weggebruiker${possibilities.length > 2 ? "s" : ""} ${possibility}`;
                        answersDOM.append(tempLabel);
                        answersDOM.append(document.createElement('br'));
                    });
                    break;
                case "whichrule":
                    // Why does x go first
                    if (data.interactions.length == 1) {
                        answer = data.interactions[0].reason;

                        questionDOM.innerHTML = "Welke regel geldt hier?"
                        explanationDOM.innerHTML = `<p><b>${answer} geldt hier.</b><br></p>`;
                    } else {
                        let randomInteraction = Math.floor(Math.random() * data.interactions.length);
                        answer = data.interactions[randomInteraction].reason;

                        questionDOM.innerHTML = `Waarom mag weggebruiker ${data.interactions[randomInteraction].winner} hier voor weggebruiker ${data.interactions[randomInteraction].actor_pair.find(num => num !== data.interactions[randomInteraction].winner)} gaan?`
                        explanationDOM.innerHTML = `<p><b>${answer} geldt hier.</b><br>Daarom mag weggebruiker ${data.interactions[randomInteraction].winner} hier voor gaan.</p>`;
                    }

                    possibilities = selectRandomElements(answer, config.oorzaken);
                    // console.log(`Which rule applies? Answer possibilities: ${possibilities}, correct answer: ${answer}`);

                    possibilities.forEach((possibility) => {
                        let tempRadio = document.createElement('input');
                        tempRadio.type = "radio";
                        tempRadio.id = possibility;
                        tempRadio.name = "actors";
                        tempRadio.value = possibility;
                        answersDOM.append(tempRadio);
                        let tempLabel = document.createElement('label');
                        tempLabel.for = possibility;
                        tempLabel.innerHTML = possibility;
                        answersDOM.append(tempLabel);
                        answersDOM.append(document.createElement('br'));
                    });
                    break;
                default:
                    console.error(`questionType ${questionType} is not defined!`);
            }
        }

        function checkAnswer(event) {
            event.preventDefault();

            let givenAnswer = document.querySelector('input[name="actors"]:checked').value;
            let correctnessDOM = document.getElementById('correctness');
            let crossingSourceDOM = document.getElementById('crossingSource');
            let explanationDOM = document.getElementById('explanation');
            let testDOM = document.getElementById('test');

            correctnessDOM.innerHTML = "";
            crossingSourceDOM.disabled = false;
            crossingSourceDOM.value = "initialValue";
            testDOM.disabled = true;

            // console.log(`givenAnswer: ${givenAnswer}, actual answer: ${answer}`, givenAnswer == answer ? "The given answer is correct!" : "The given answer is incorrect :(");
            if (givenAnswer == answer) {
                correctnessDOM.innerHTML += "✔️";
            } else {
                correctnessDOM.innerHTML += "❌";
            }

            // Display correct answer
            explanationDOM.style.display = 'block';
        }

        function changeScenario() {
            let scenario = document.getElementById('crossingSource').value;
            fetch(`./assets/scenarios/${scenario}`)
                .then((response) => response.json())
                .then((json) => {
                    data = json;
                    crossingImg = loadImage(data.background);

                    questionGenerator();
                });

            document.getElementById('crossingSource').disabled = true;

            // Reset all question values
            let questionDOM = document.getElementById("question");
            let answersDOM = document.getElementById('answers');
            let explanationDOM = document.getElementById('explanation');
            let testDOM = document.getElementById('test');
            let correctnessDOM = document.getElementById('correctness');

            questionDOM.innerHTML = "";
            answersDOM.innerHTML = "";
            explanationDOM.innerHTML = "";
            explanationDOM.style.display = "none";
            correctnessDOM.innerHTML = "";
            testDOM.disabled = false;
        }

        function generatePermutations(n) {
            // Base case: if n is 0 or 1, return the simple permutation
            if (n <= 1) {
                return [Array.from({ length: n }, (_, i) => i)];
            }

            const result = [];

            // Recursive helper function to generate permutations
            function backtrack(currentPerm, used) {
                // If current permutation is complete, add it to results
                if (currentPerm.length === n) {
                    result.push([...currentPerm]);
                    return;
                }

                // Try adding each unused number
                for (let i = 0; i < n; i++) {
                    if (!used[i]) {
                        // Mark as used
                        used[i] = true;
                        currentPerm.push(i);

                        // Recursively generate permutations
                        backtrack(currentPerm, used);

                        // Backtrack
                        currentPerm.pop();
                        used[i] = false;
                    }
                }
            }

            // Start the backtracking process
            backtrack([], new Array(n).fill(false));

            return result;
        }

        function selectRandomElements(originalValue, otherValues) {
            // Create a copy of the other values array to avoid modifying the original
            let availableValues = [...otherValues];

            // Shuffle the available values
            for (let i = availableValues.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availableValues[i], availableValues[j]] = [availableValues[j], availableValues[i]];
            }

            // Select up to 3 unique values from the shuffled array
            const selectedValues = availableValues.slice(0, 3);

            // Create the final array with the original value and selected values
            let resultArray = [originalValue, ...selectedValues];

            // Shuffle the result array to randomize the position of the original value
            for (let i = resultArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [resultArray[i], resultArray[j]] = [resultArray[j], resultArray[i]];
            }

            return resultArray;
        }

        function determineWinnerOrder(interactions) {
            // Create adjacency lists for wins and losses
            const wins = {};
            const losses = {};

            // Initialize tracking for all actors
            const actors = new Set();
            interactions.forEach(interaction => {
                actors.add(interaction.actor_pair[0]);
                actors.add(interaction.actor_pair[1]);

                const winner = interaction.winner;
                const [loser] = interaction.actor_pair.filter(a => a !== winner);

                wins[winner] = wins[winner] || [];
                losses[loser] = losses[loser] || [];

                wins[winner].push(loser);
                losses[loser].push(winner);
            });

            // Topological sort
            const order = [];
            const visited = new Set();

            function dfs(node) {
                if (visited.has(node)) return;
                visited.add(node);

                // Recursively visit nodes this node loses to
                if (losses[node]) {
                    losses[node].forEach(loserTo => {
                        if (!visited.has(loserTo)) {
                            dfs(loserTo);
                        }
                    });
                }

                // Add to order if not already present
                if (!order.includes(node)) {
                    order.push(node);
                }
            }

            // Start DFS from each unvisited actor
            for (let actor of actors) {
                if (!visited.has(actor)) {
                    dfs(actor);
                }
            }

            return order;
        }

        // Draw the destination arrow to indicate where actors want to travel to
        function drawArrow(startX, startY, endX, endY) {
            // Calculate the angle and length of the arrow
            let angle = atan2(endY - startY, endX - startX);
            let distance = dist(startX, startY, endX, endY);

            // Draw the angle at the start coordinates
            push();
            translate(startX, startY);
            rotate(angle);

            stroke(0);
            strokeWeight(2);
            line(0, 0, distance, 0);

            // Draw the arrow head at the destination coordinates using the calculated vector
            fill(0);
            noStroke();
            beginShape();
            vertex(distance, 0);
            vertex(distance - 10, -5);
            vertex(distance - 10, 5);
            endShape(CLOSE);
            pop();
        }

        // Define actor image variable to house all actor image objects
        let actorImgs = [];
        let config = null;
        // Load data before the visualiser is started
        function preload() {
            fetch('./config.json')
                .then((response) => response.json())
                .then((json) => {
                    config = json;

                    config.actors.forEach((actor) => {
                        actorImgs.push({
                            "type": actor.identifier,
                            "img": loadImage(actor.file)
                        });
                    });
                });

            fetch('./assets/scenarios/scenarios.json')
                .then((response) => response.json())
                .then((json) => {
                    let crossingSelector = document.getElementById('crossingSource');
                    json.forEach((scenario) => {
                        let tempOption = document.createElement('option');
                        tempOption.value = scenario.file;
                        tempOption.innerHTML = scenario.scenario_name;
                        crossingSelector.appendChild(tempOption);
                    });
                });
        }

    </script>

</body>

</html>